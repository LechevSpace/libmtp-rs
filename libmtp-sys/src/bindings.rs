/* automatically generated by rust-bindgen 0.55.1 */

pub type time_t = libc::time_t;
pub type timeval = libc::timeval;

pub const LIBMTP_VERSION_STRING: &'static [u8; 7usize] = b"1.1.17\0";
pub const LIBMTP_DEBUG_NONE: u32 = 0;
pub const LIBMTP_DEBUG_PTP: u32 = 1;
pub const LIBMTP_DEBUG_PLST: u32 = 2;
pub const LIBMTP_DEBUG_USB: u32 = 4;
pub const LIBMTP_DEBUG_DATA: u32 = 8;
pub const LIBMTP_DEBUG_ALL: u32 = 255;
pub const LIBMTP_HANDLER_RETURN_OK: u32 = 0;
pub const LIBMTP_HANDLER_RETURN_ERROR: u32 = 1;
pub const LIBMTP_HANDLER_RETURN_CANCEL: u32 = 2;
pub const LIBMTP_STORAGE_SORTBY_NOTSORTED: u32 = 0;
pub const LIBMTP_STORAGE_SORTBY_FREESPACE: u32 = 1;
pub const LIBMTP_STORAGE_SORTBY_MAXSPACE: u32 = 2;
pub const LIBMTP_FILES_AND_FOLDERS_ROOT: u32 = 4294967295;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_FOLDER: LIBMTP_filetype_t = 0;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_WAV: LIBMTP_filetype_t = 1;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MP3: LIBMTP_filetype_t = 2;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_WMA: LIBMTP_filetype_t = 3;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_OGG: LIBMTP_filetype_t = 4;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_AUDIBLE: LIBMTP_filetype_t = 5;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MP4: LIBMTP_filetype_t = 6;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_UNDEF_AUDIO: LIBMTP_filetype_t = 7;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_WMV: LIBMTP_filetype_t = 8;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_AVI: LIBMTP_filetype_t = 9;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MPEG: LIBMTP_filetype_t = 10;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_ASF: LIBMTP_filetype_t = 11;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_QT: LIBMTP_filetype_t = 12;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_UNDEF_VIDEO: LIBMTP_filetype_t = 13;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_JPEG: LIBMTP_filetype_t = 14;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_JFIF: LIBMTP_filetype_t = 15;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_TIFF: LIBMTP_filetype_t = 16;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_BMP: LIBMTP_filetype_t = 17;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_GIF: LIBMTP_filetype_t = 18;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_PICT: LIBMTP_filetype_t = 19;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_PNG: LIBMTP_filetype_t = 20;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_VCALENDAR1: LIBMTP_filetype_t = 21;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_VCALENDAR2: LIBMTP_filetype_t = 22;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_VCARD2: LIBMTP_filetype_t = 23;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_VCARD3: LIBMTP_filetype_t = 24;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_WINDOWSIMAGEFORMAT: LIBMTP_filetype_t = 25;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_WINEXEC: LIBMTP_filetype_t = 26;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_TEXT: LIBMTP_filetype_t = 27;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_HTML: LIBMTP_filetype_t = 28;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_FIRMWARE: LIBMTP_filetype_t = 29;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_AAC: LIBMTP_filetype_t = 30;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MEDIACARD: LIBMTP_filetype_t = 31;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_FLAC: LIBMTP_filetype_t = 32;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MP2: LIBMTP_filetype_t = 33;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_M4A: LIBMTP_filetype_t = 34;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_DOC: LIBMTP_filetype_t = 35;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_XML: LIBMTP_filetype_t = 36;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_XLS: LIBMTP_filetype_t = 37;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_PPT: LIBMTP_filetype_t = 38;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_MHT: LIBMTP_filetype_t = 39;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_JP2: LIBMTP_filetype_t = 40;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_JPX: LIBMTP_filetype_t = 41;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_ALBUM: LIBMTP_filetype_t = 42;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_PLAYLIST: LIBMTP_filetype_t = 43;
pub const LIBMTP_filetype_t_LIBMTP_FILETYPE_UNKNOWN: LIBMTP_filetype_t = 44;
#[doc = " The filetypes defined here are the external types used"]
#[doc = " by the libmtp library interface. The types used internally"]
#[doc = " as PTP-defined enumerator types is something different."]
pub type LIBMTP_filetype_t = ::std::os::raw::c_uint;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_StorageID: LIBMTP_property_t = 0;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ObjectFormat: LIBMTP_property_t = 1;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ProtectionStatus: LIBMTP_property_t = 2;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ObjectSize: LIBMTP_property_t = 3;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AssociationType: LIBMTP_property_t = 4;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AssociationDesc: LIBMTP_property_t = 5;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ObjectFileName: LIBMTP_property_t = 6;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DateCreated: LIBMTP_property_t = 7;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DateModified: LIBMTP_property_t = 8;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Keywords: LIBMTP_property_t = 9;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ParentObject: LIBMTP_property_t = 10;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AllowedFolderContents: LIBMTP_property_t = 11;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Hidden: LIBMTP_property_t = 12;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SystemObject: LIBMTP_property_t = 13;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PersistantUniqueObjectIdentifier: LIBMTP_property_t =
    14;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SyncID: LIBMTP_property_t = 15;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PropertyBag: LIBMTP_property_t = 16;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Name: LIBMTP_property_t = 17;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_CreatedBy: LIBMTP_property_t = 18;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Artist: LIBMTP_property_t = 19;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DateAuthored: LIBMTP_property_t = 20;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Description: LIBMTP_property_t = 21;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_URLReference: LIBMTP_property_t = 22;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_LanguageLocale: LIBMTP_property_t = 23;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_CopyrightInformation: LIBMTP_property_t = 24;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Source: LIBMTP_property_t = 25;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_OriginLocation: LIBMTP_property_t = 26;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DateAdded: LIBMTP_property_t = 27;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_NonConsumable: LIBMTP_property_t = 28;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_CorruptOrUnplayable: LIBMTP_property_t = 29;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ProducerSerialNumber: LIBMTP_property_t = 30;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleFormat: LIBMTP_property_t = 31;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleSize: LIBMTP_property_t = 32;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleHeight: LIBMTP_property_t = 33;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleWidth: LIBMTP_property_t = 34;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleDuration: LIBMTP_property_t = 35;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_RepresentativeSampleData: LIBMTP_property_t = 36;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Width: LIBMTP_property_t = 37;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Height: LIBMTP_property_t = 38;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Duration: LIBMTP_property_t = 39;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Rating: LIBMTP_property_t = 40;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Track: LIBMTP_property_t = 41;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Genre: LIBMTP_property_t = 42;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Credits: LIBMTP_property_t = 43;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Lyrics: LIBMTP_property_t = 44;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SubscriptionContentID: LIBMTP_property_t = 45;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ProducedBy: LIBMTP_property_t = 46;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_UseCount: LIBMTP_property_t = 47;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SkipCount: LIBMTP_property_t = 48;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_LastAccessed: LIBMTP_property_t = 49;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ParentalRating: LIBMTP_property_t = 50;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MetaGenre: LIBMTP_property_t = 51;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Composer: LIBMTP_property_t = 52;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EffectiveRating: LIBMTP_property_t = 53;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Subtitle: LIBMTP_property_t = 54;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_OriginalReleaseDate: LIBMTP_property_t = 55;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AlbumName: LIBMTP_property_t = 56;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AlbumArtist: LIBMTP_property_t = 57;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Mood: LIBMTP_property_t = 58;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DRMStatus: LIBMTP_property_t = 59;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SubDescription: LIBMTP_property_t = 60;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_IsCropped: LIBMTP_property_t = 61;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_IsColorCorrected: LIBMTP_property_t = 62;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ImageBitDepth: LIBMTP_property_t = 63;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Fnumber: LIBMTP_property_t = 64;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ExposureTime: LIBMTP_property_t = 65;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ExposureIndex: LIBMTP_property_t = 66;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_DisplayName: LIBMTP_property_t = 67;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_BodyText: LIBMTP_property_t = 68;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Subject: LIBMTP_property_t = 69;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Priority: LIBMTP_property_t = 70;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_GivenName: LIBMTP_property_t = 71;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MiddleNames: LIBMTP_property_t = 72;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_FamilyName: LIBMTP_property_t = 73;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Prefix: LIBMTP_property_t = 74;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Suffix: LIBMTP_property_t = 75;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneticGivenName: LIBMTP_property_t = 76;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneticFamilyName: LIBMTP_property_t = 77;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailPrimary: LIBMTP_property_t = 78;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailPersonal1: LIBMTP_property_t = 79;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailPersonal2: LIBMTP_property_t = 80;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailBusiness1: LIBMTP_property_t = 81;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailBusiness2: LIBMTP_property_t = 82;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EmailOthers: LIBMTP_property_t = 83;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberPrimary: LIBMTP_property_t = 84;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberPersonal: LIBMTP_property_t = 85;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberPersonal2: LIBMTP_property_t = 86;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberBusiness: LIBMTP_property_t = 87;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberBusiness2: LIBMTP_property_t = 88;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberMobile: LIBMTP_property_t = 89;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberMobile2: LIBMTP_property_t = 90;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_FaxNumberPrimary: LIBMTP_property_t = 91;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_FaxNumberPersonal: LIBMTP_property_t = 92;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_FaxNumberBusiness: LIBMTP_property_t = 93;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PagerNumber: LIBMTP_property_t = 94;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneNumberOthers: LIBMTP_property_t = 95;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PrimaryWebAddress: LIBMTP_property_t = 96;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PersonalWebAddress: LIBMTP_property_t = 97;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_BusinessWebAddress: LIBMTP_property_t = 98;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_InstantMessengerAddress: LIBMTP_property_t = 99;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_InstantMessengerAddress2: LIBMTP_property_t = 100;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_InstantMessengerAddress3: LIBMTP_property_t = 101;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFull: LIBMTP_property_t = 102;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullLine1: LIBMTP_property_t = 103;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullLine2: LIBMTP_property_t = 104;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullCity: LIBMTP_property_t = 105;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullRegion: LIBMTP_property_t =
    106;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullPostalCode: LIBMTP_property_t =
    107;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressPersonalFullCountry: LIBMTP_property_t =
    108;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessFull: LIBMTP_property_t = 109;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessLine1: LIBMTP_property_t = 110;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessLine2: LIBMTP_property_t = 111;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessCity: LIBMTP_property_t = 112;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessRegion: LIBMTP_property_t = 113;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessPostalCode: LIBMTP_property_t =
    114;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressBusinessCountry: LIBMTP_property_t = 115;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherFull: LIBMTP_property_t = 116;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherLine1: LIBMTP_property_t = 117;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherLine2: LIBMTP_property_t = 118;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherCity: LIBMTP_property_t = 119;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherRegion: LIBMTP_property_t = 120;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherPostalCode: LIBMTP_property_t = 121;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PostalAddressOtherCountry: LIBMTP_property_t = 122;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_OrganizationName: LIBMTP_property_t = 123;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_PhoneticOrganizationName: LIBMTP_property_t = 124;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Role: LIBMTP_property_t = 125;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Birthdate: LIBMTP_property_t = 126;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageTo: LIBMTP_property_t = 127;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageCC: LIBMTP_property_t = 128;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageBCC: LIBMTP_property_t = 129;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageRead: LIBMTP_property_t = 130;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageReceivedTime: LIBMTP_property_t = 131;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MessageSender: LIBMTP_property_t = 132;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityBeginTime: LIBMTP_property_t = 133;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityEndTime: LIBMTP_property_t = 134;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityLocation: LIBMTP_property_t = 135;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityRequiredAttendees: LIBMTP_property_t = 136;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityOptionalAttendees: LIBMTP_property_t = 137;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityResources: LIBMTP_property_t = 138;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ActivityAccepted: LIBMTP_property_t = 139;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Owner: LIBMTP_property_t = 140;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Editor: LIBMTP_property_t = 141;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_Webmaster: LIBMTP_property_t = 142;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_URLSource: LIBMTP_property_t = 143;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_URLDestination: LIBMTP_property_t = 144;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_TimeBookmark: LIBMTP_property_t = 145;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ObjectBookmark: LIBMTP_property_t = 146;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ByteBookmark: LIBMTP_property_t = 147;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_LastBuildDate: LIBMTP_property_t = 148;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_TimetoLive: LIBMTP_property_t = 149;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_MediaGUID: LIBMTP_property_t = 150;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_TotalBitRate: LIBMTP_property_t = 151;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_BitRateType: LIBMTP_property_t = 152;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_SampleRate: LIBMTP_property_t = 153;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_NumberOfChannels: LIBMTP_property_t = 154;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AudioBitDepth: LIBMTP_property_t = 155;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_ScanDepth: LIBMTP_property_t = 156;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AudioWAVECodec: LIBMTP_property_t = 157;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_AudioBitRate: LIBMTP_property_t = 158;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_VideoFourCCCodec: LIBMTP_property_t = 159;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_VideoBitRate: LIBMTP_property_t = 160;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_FramesPerThousandSeconds: LIBMTP_property_t = 161;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_KeyFrameDistance: LIBMTP_property_t = 162;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_BufferSize: LIBMTP_property_t = 163;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EncodingQuality: LIBMTP_property_t = 164;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_EncodingProfile: LIBMTP_property_t = 165;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_BuyFlag: LIBMTP_property_t = 166;
pub const LIBMTP_property_t_LIBMTP_PROPERTY_UNKNOWN: LIBMTP_property_t = 167;
#[doc = " The properties defined here are the external types used"]
#[doc = " by the libmtp library interface."]
pub type LIBMTP_property_t = ::std::os::raw::c_uint;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_INT8: LIBMTP_datatype_t = 0;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_UINT8: LIBMTP_datatype_t = 1;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_INT16: LIBMTP_datatype_t = 2;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_UINT16: LIBMTP_datatype_t = 3;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_INT32: LIBMTP_datatype_t = 4;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_UINT32: LIBMTP_datatype_t = 5;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_INT64: LIBMTP_datatype_t = 6;
pub const LIBMTP_datatype_t_LIBMTP_DATATYPE_UINT64: LIBMTP_datatype_t = 7;
#[doc = " These are the data types"]
pub type LIBMTP_datatype_t = ::std::os::raw::c_uint;
#[doc = " This capability tells whether you can call the function getting"]
#[doc = " partial objects, @see LIBMTP_GetPartialObject()"]
pub const LIBMTP_devicecap_t_LIBMTP_DEVICECAP_GetPartialObject: LIBMTP_devicecap_t = 0;
#[doc = " This capability tells whether you can call the function sending"]
#[doc = " partial objects. @see LIBMTP_SendPartialObject()"]
pub const LIBMTP_devicecap_t_LIBMTP_DEVICECAP_SendPartialObject: LIBMTP_devicecap_t = 1;
#[doc = " This capability tells whether you can call the functions editing"]
#[doc = " objects in-place on a device."]
#[doc = " @see LIBMTP_BeginEditObject()"]
#[doc = " @see LIBMTP_EndEditObject()"]
#[doc = " @see LIBMTP_TruncateObject()"]
pub const LIBMTP_devicecap_t_LIBMTP_DEVICECAP_EditObjects: LIBMTP_devicecap_t = 2;
#[doc = " This capability tells whether you can call the function to"]
#[doc = " move an object, @see LIBMTP_MoveObject()"]
pub const LIBMTP_devicecap_t_LIBMTP_DEVICECAP_MoveObject: LIBMTP_devicecap_t = 3;
#[doc = " This capability tells whether you can call the function to"]
#[doc = " copy an object, @see LIBMTP_CopyObject()"]
pub const LIBMTP_devicecap_t_LIBMTP_DEVICECAP_CopyObject: LIBMTP_devicecap_t = 4;
#[doc = " These are device capabilities"]
pub type LIBMTP_devicecap_t = ::std::os::raw::c_uint;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_NONE: LIBMTP_error_number_t = 0;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_GENERAL: LIBMTP_error_number_t = 1;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_PTP_LAYER: LIBMTP_error_number_t = 2;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_USB_LAYER: LIBMTP_error_number_t = 3;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_MEMORY_ALLOCATION: LIBMTP_error_number_t = 4;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_NO_DEVICE_ATTACHED: LIBMTP_error_number_t = 5;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_STORAGE_FULL: LIBMTP_error_number_t = 6;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_CONNECTING: LIBMTP_error_number_t = 7;
pub const LIBMTP_error_number_t_LIBMTP_ERROR_CANCELLED: LIBMTP_error_number_t = 8;
#[doc = " These are the numbered error codes. You can also"]
#[doc = " get string representations for errors."]
pub type LIBMTP_error_number_t = ::std::os::raw::c_uint;
pub type LIBMTP_device_entry_t = LIBMTP_device_entry_struct;
pub type LIBMTP_raw_device_t = LIBMTP_raw_device_struct;
pub type LIBMTP_error_t = LIBMTP_error_struct;
pub type LIBMTP_allowed_values_t = LIBMTP_allowed_values_struct;
pub type LIBMTP_device_extension_t = LIBMTP_device_extension_struct;
#[doc = " < @see LIBMTP_device_extension_struct"]
pub type LIBMTP_mtpdevice_t = LIBMTP_mtpdevice_struct;
pub type LIBMTP_file_t = LIBMTP_file_struct;
pub type LIBMTP_track_t = LIBMTP_track_struct;
pub type LIBMTP_playlist_t = LIBMTP_playlist_struct;
pub type LIBMTP_album_t = LIBMTP_album_struct;
pub type LIBMTP_folder_t = LIBMTP_folder_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIBMTP_object_struct {
    _unused: [u8; 0],
}
pub type LIBMTP_object_t = LIBMTP_object_struct;
pub type LIBMTP_filesampledata_t = LIBMTP_filesampledata_struct;
pub type LIBMTP_devicestorage_t = LIBMTP_devicestorage_struct;
#[doc = " The callback type definition. Notice that a progress percentage ratio"]
#[doc = " is easy to calculate by dividing <code>sent</code> by"]
#[doc = " <code>total</code>."]
#[doc = " @param sent the number of bytes sent so far"]
#[doc = " @param total the total number of bytes to send"]
#[doc = " @param data a user-defined dereferencable pointer"]
#[doc = " @return if anything else than 0 is returned, the current transfer will be"]
#[doc = "         interrupted / cancelled."]
pub type LIBMTP_progressfunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        sent: u64,
        total: u64,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback function for get by handler function"]
#[doc = " @param params the device parameters"]
#[doc = " @param priv a user-defined dereferencable pointer"]
#[doc = " @param wantlen the number of bytes wanted"]
#[doc = " @param data a buffer to write the data to"]
#[doc = " @param gotlen pointer to the number of bytes actually written"]
#[doc = "        to data"]
#[doc = " @return LIBMTP_HANDLER_RETURN_OK if successful,"]
#[doc = "         LIBMTP_HANDLER_RETURN_ERROR on error or"]
#[doc = "         LIBMTP_HANDLER_RETURN_CANCEL to cancel the transfer"]
pub type MTPDataGetFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ::std::os::raw::c_void,
        priv_: *mut ::std::os::raw::c_void,
        wantlen: u32,
        data: *mut ::std::os::raw::c_uchar,
        gotlen: *mut u32,
    ) -> u16,
>;
#[doc = " Callback function for put by handler function"]
#[doc = " @param params the device parameters"]
#[doc = " @param priv a user-defined dereferencable pointer"]
#[doc = " @param sendlen the number of bytes available"]
#[doc = " @param data a buffer to read the data from"]
#[doc = " @param putlen pointer to the number of bytes actually read"]
#[doc = "        from data"]
#[doc = " @return LIBMTP_HANDLER_RETURN_OK if successful,"]
#[doc = "         LIBMTP_HANDLER_RETURN_ERROR on error or"]
#[doc = "         LIBMTP_HANDLER_RETURN_CANCEL to cancel the transfer"]
pub type MTPDataPutFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ::std::os::raw::c_void,
        priv_: *mut ::std::os::raw::c_void,
        sendlen: u32,
        data: *mut ::std::os::raw::c_uchar,
        putlen: *mut u32,
    ) -> u16,
>;
#[doc = " A data structure to hold MTP device entries."]
#[repr(C)]
pub struct LIBMTP_device_entry_struct {
    #[doc = "< The vendor of this device"]
    pub vendor: *mut ::std::os::raw::c_char,
    #[doc = "< Vendor ID for this device"]
    pub vendor_id: u16,
    #[doc = "< The product name of this device"]
    pub product: *mut ::std::os::raw::c_char,
    #[doc = "< Product ID for this device"]
    pub product_id: u16,
    #[doc = "< Bugs, device specifics etc"]
    pub device_flags: u32,
}
#[test]
fn bindgen_test_layout_LIBMTP_device_entry_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_device_entry_struct>(),
        32usize,
        concat!("Size of: ", stringify!(LIBMTP_device_entry_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_device_entry_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_device_entry_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_entry_struct>())).vendor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_entry_struct),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_entry_struct>())).vendor_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_entry_struct),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_entry_struct>())).product as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_entry_struct),
            "::",
            stringify!(product)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_entry_struct>())).product_id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_entry_struct),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_entry_struct>())).device_flags as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_entry_struct),
            "::",
            stringify!(device_flags)
        )
    );
}
#[doc = " A data structure to hold a raw MTP device connected"]
#[doc = " to the bus."]
#[repr(C)]
pub struct LIBMTP_raw_device_struct {
    #[doc = "< The device entry for this raw device"]
    pub device_entry: LIBMTP_device_entry_t,
    #[doc = "< Location of the bus, if device available"]
    pub bus_location: u32,
    #[doc = "< Device number on the bus, if device available"]
    pub devnum: u8,
}
#[test]
fn bindgen_test_layout_LIBMTP_raw_device_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_raw_device_struct>(),
        40usize,
        concat!("Size of: ", stringify!(LIBMTP_raw_device_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_raw_device_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_raw_device_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_raw_device_struct>())).device_entry as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_raw_device_struct),
            "::",
            stringify!(device_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_raw_device_struct>())).bus_location as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_raw_device_struct),
            "::",
            stringify!(bus_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_raw_device_struct>())).devnum as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_raw_device_struct),
            "::",
            stringify!(devnum)
        )
    );
}
#[doc = " A data structure to hold errors from the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIBMTP_error_struct {
    pub errornumber: LIBMTP_error_number_t,
    pub error_text: *mut ::std::os::raw::c_char,
    pub next: *mut LIBMTP_error_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_error_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_error_struct>(),
        24usize,
        concat!("Size of: ", stringify!(LIBMTP_error_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_error_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_error_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_error_struct>())).errornumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_error_struct),
            "::",
            stringify!(errornumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_error_struct>())).error_text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_error_struct),
            "::",
            stringify!(error_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_error_struct>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_error_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " A data structure to hold allowed ranges of values"]
#[repr(C)]
pub struct LIBMTP_allowed_values_struct {
    pub u8max: u8,
    pub u8min: u8,
    pub u8step: u8,
    pub u8vals: *mut u8,
    pub i8max: i8,
    pub i8min: i8,
    pub i8step: i8,
    pub i8vals: *mut i8,
    pub u16max: u16,
    pub u16min: u16,
    pub u16step: u16,
    pub u16vals: *mut u16,
    pub i16max: i16,
    pub i16min: i16,
    pub i16step: i16,
    pub i16vals: *mut i16,
    pub u32max: u32,
    pub u32min: u32,
    pub u32step: u32,
    pub u32vals: *mut u32,
    pub i32max: i32,
    pub i32min: i32,
    pub i32step: i32,
    pub i32vals: *mut i32,
    pub u64max: u64,
    pub u64min: u64,
    pub u64step: u64,
    pub u64vals: *mut u64,
    pub i64max: i64,
    pub i64min: i64,
    pub i64step: i64,
    pub i64vals: *mut i64,
    #[doc = " Number of entries in the vals array"]
    pub num_entries: u16,
    #[doc = " The datatype specifying which of the above is used"]
    pub datatype: LIBMTP_datatype_t,
    #[doc = " Non zero for range, 0 for enum"]
    pub is_range: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LIBMTP_allowed_values_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_allowed_values_struct>(),
        192usize,
        concat!("Size of: ", stringify!(LIBMTP_allowed_values_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_allowed_values_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_allowed_values_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u8max as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u8max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u8min as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u8min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u8step as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u8step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u8vals as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u8vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i8max as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i8max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i8min as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i8min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i8step as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i8step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i8vals as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i8vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u16max as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u16max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u16min as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u16min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u16step as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u16step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u16vals as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u16vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i16max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i16max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i16min as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i16min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i16step as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i16step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i16vals as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i16vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u32max as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u32max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u32min as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u32min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u32step as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u32step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u32vals as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u32vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i32max as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i32max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i32min as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i32min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i32step as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i32step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i32vals as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i32vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u64max as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u64max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u64min as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u64min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u64step as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u64step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).u64vals as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(u64vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i64max as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i64max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i64min as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i64min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i64step as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i64step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).i64vals as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(i64vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).num_entries as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).datatype as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_allowed_values_struct>())).is_range as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_allowed_values_struct),
            "::",
            stringify!(is_range)
        )
    );
}
#[doc = " MTP device extension holder struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIBMTP_device_extension_struct {
    #[doc = " Name of extension e.g. \"foo.com\""]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Major revision of extension"]
    pub major: ::std::os::raw::c_int,
    #[doc = " Minor revision of extension"]
    pub minor: ::std::os::raw::c_int,
    #[doc = " Pointer to the next extension or NULL if this is the"]
    #[doc = " last extension."]
    pub next: *mut LIBMTP_device_extension_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_device_extension_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_device_extension_struct>(),
        24usize,
        concat!("Size of: ", stringify!(LIBMTP_device_extension_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_device_extension_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_device_extension_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_extension_struct>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_extension_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_extension_struct>())).major as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_extension_struct),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_extension_struct>())).minor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_extension_struct),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_device_extension_struct>())).next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_device_extension_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Main MTP device object struct"]
#[repr(C)]
pub struct LIBMTP_mtpdevice_struct {
    #[doc = " Object bitsize, typically 32 or 64."]
    pub object_bitsize: u8,
    #[doc = " Parameters for this device, must be cast into"]
    #[doc = " \\c (PTPParams*) before internal use."]
    pub params: *mut ::std::os::raw::c_void,
    #[doc = " USB device for this device, must be cast into"]
    #[doc = " \\c (PTP_USB*) before internal use."]
    pub usbinfo: *mut ::std::os::raw::c_void,
    #[doc = " The storage for this device, do not use strings in here without"]
    #[doc = " copying them first, and beware that this list may be rebuilt at"]
    #[doc = " any time."]
    #[doc = " @see LIBMTP_Get_Storage()"]
    pub storage: *mut LIBMTP_devicestorage_t,
    #[doc = " The error stack. This shall be handled using the error getting"]
    #[doc = " and clearing functions, not by dereferencing this list."]
    pub errorstack: *mut LIBMTP_error_t,
    #[doc = " The maximum battery level for this device"]
    pub maximum_battery_level: u8,
    #[doc = " Default music folder"]
    pub default_music_folder: u32,
    #[doc = " Default playlist folder"]
    pub default_playlist_folder: u32,
    #[doc = " Default picture folder"]
    pub default_picture_folder: u32,
    #[doc = " Default video folder"]
    pub default_video_folder: u32,
    #[doc = " Default organizer folder"]
    pub default_organizer_folder: u32,
    #[doc = " Default ZENcast folder (only Creative devices...)"]
    pub default_zencast_folder: u32,
    #[doc = " Default Album folder"]
    pub default_album_folder: u32,
    #[doc = " Default Text folder"]
    pub default_text_folder: u32,
    #[doc = " Per device iconv() converters, only used internally"]
    pub cd: *mut ::std::os::raw::c_void,
    #[doc = " Extension list"]
    pub extensions: *mut LIBMTP_device_extension_t,
    #[doc = " Whether the device uses caching, only used internally"]
    pub cached: ::std::os::raw::c_int,
    #[doc = " Pointer to next device in linked list; NULL if this is the last device"]
    pub next: *mut LIBMTP_mtpdevice_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_mtpdevice_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_mtpdevice_struct>(),
        112usize,
        concat!("Size of: ", stringify!(LIBMTP_mtpdevice_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_mtpdevice_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_mtpdevice_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).object_bitsize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(object_bitsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).usbinfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(usbinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).storage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).errorstack as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(errorstack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).maximum_battery_level as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(maximum_battery_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_music_folder as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_music_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_playlist_folder as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_playlist_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_picture_folder as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_picture_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_video_folder as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_video_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_organizer_folder as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_organizer_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_zencast_folder as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_zencast_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_album_folder as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_album_folder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).default_text_folder as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(default_text_folder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).cd as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(cd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).extensions as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).cached as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(cached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_mtpdevice_struct>())).next as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_mtpdevice_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " MTP file struct"]
#[repr(C)]
pub struct LIBMTP_file_struct {
    #[doc = "< Unique item ID"]
    pub item_id: u32,
    #[doc = "< ID of parent folder"]
    pub parent_id: u32,
    #[doc = "< ID of storage holding this file"]
    pub storage_id: u32,
    #[doc = "< Filename of this file"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = "< Size of file in bytes"]
    pub filesize: u64,
    #[doc = "< Date of last alteration of the file"]
    pub modificationdate: time_t,
    #[doc = "< Filetype used for the current file"]
    pub filetype: LIBMTP_filetype_t,
    #[doc = "< Next file in list or NULL if last file"]
    pub next: *mut LIBMTP_file_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_file_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_file_struct>(),
        56usize,
        concat!("Size of: ", stringify!(LIBMTP_file_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_file_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_file_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).item_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(item_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).parent_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).storage_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(storage_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).filesize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(filesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_file_struct>())).modificationdate as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(modificationdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).filetype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_file_struct>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_file_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " MTP track struct"]
#[repr(C)]
pub struct LIBMTP_track_struct {
    #[doc = "< Unique item ID"]
    pub item_id: u32,
    #[doc = "< ID of parent folder"]
    pub parent_id: u32,
    #[doc = "< ID of storage holding this track"]
    pub storage_id: u32,
    #[doc = "< Track title"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< Name of recording artist"]
    pub artist: *mut ::std::os::raw::c_char,
    #[doc = "< Name of recording composer"]
    pub composer: *mut ::std::os::raw::c_char,
    #[doc = "< Genre name for track"]
    pub genre: *mut ::std::os::raw::c_char,
    #[doc = "< Album name for track"]
    pub album: *mut ::std::os::raw::c_char,
    #[doc = "< Date of original recording as a string"]
    pub date: *mut ::std::os::raw::c_char,
    #[doc = "< Original filename of this track"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = "< Track number (in sequence on recording)"]
    pub tracknumber: u16,
    #[doc = "< Duration in milliseconds"]
    pub duration: u32,
    #[doc = "< Sample rate of original file, min 0x1f80 max 0xbb80"]
    pub samplerate: u32,
    #[doc = "< Number of channels in this recording 0 = unknown, 1 or 2"]
    pub nochannels: u16,
    #[doc = "< FourCC wave codec name"]
    pub wavecodec: u32,
    #[doc = "< (Average) bitrate for this file min=1 max=0x16e360"]
    pub bitrate: u32,
    #[doc = "< 0 = unused, 1 = constant, 2 = VBR, 3 = free"]
    pub bitratetype: u16,
    #[doc = "< User rating 0-100 (0x00-0x64)"]
    pub rating: u16,
    #[doc = "< Number of times used/played"]
    pub usecount: u32,
    #[doc = "< Size of track file in bytes"]
    pub filesize: u64,
    #[doc = "< Date of last alteration of the track"]
    pub modificationdate: time_t,
    #[doc = "< Filetype used for the current track"]
    pub filetype: LIBMTP_filetype_t,
    #[doc = "< Next track in list or NULL if last track"]
    pub next: *mut LIBMTP_track_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_track_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_track_struct>(),
        136usize,
        concat!("Size of: ", stringify!(LIBMTP_track_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_track_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_track_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).item_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(item_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).parent_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).storage_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(storage_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).title as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).artist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(artist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).composer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(composer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).genre as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(genre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).album as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(album)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).date as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).filename as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).tracknumber as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(tracknumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).duration as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).samplerate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).nochannels as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(nochannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).wavecodec as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(wavecodec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).bitrate as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).bitratetype as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(bitratetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).rating as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(rating)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).usecount as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(usecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).filesize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(filesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_track_struct>())).modificationdate as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(modificationdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).filetype as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_track_struct>())).next as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_track_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " MTP Playlist structure"]
#[repr(C)]
pub struct LIBMTP_playlist_struct {
    #[doc = "< Unique playlist ID"]
    pub playlist_id: u32,
    #[doc = "< ID of parent folder"]
    pub parent_id: u32,
    #[doc = "< ID of storage holding this playlist"]
    pub storage_id: u32,
    #[doc = "< Name of playlist"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< The tracks in this playlist"]
    pub tracks: *mut u32,
    #[doc = "< The number of tracks in this playlist"]
    pub no_tracks: u32,
    #[doc = "< Next playlist or NULL if last playlist"]
    pub next: *mut LIBMTP_playlist_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_playlist_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_playlist_struct>(),
        48usize,
        concat!("Size of: ", stringify!(LIBMTP_playlist_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_playlist_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_playlist_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).playlist_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(playlist_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).parent_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).storage_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(storage_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).tracks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(tracks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).no_tracks as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(no_tracks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_playlist_struct>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_playlist_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " MTP Album structure"]
#[repr(C)]
pub struct LIBMTP_album_struct {
    #[doc = "< Unique playlist ID"]
    pub album_id: u32,
    #[doc = "< ID of parent folder"]
    pub parent_id: u32,
    #[doc = "< ID of storage holding this album"]
    pub storage_id: u32,
    #[doc = "< Name of album"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Name of album artist"]
    pub artist: *mut ::std::os::raw::c_char,
    #[doc = "< Name of recording composer"]
    pub composer: *mut ::std::os::raw::c_char,
    #[doc = "< Genre of album"]
    pub genre: *mut ::std::os::raw::c_char,
    #[doc = "< The tracks in this album"]
    pub tracks: *mut u32,
    #[doc = "< The number of tracks in this album"]
    pub no_tracks: u32,
    #[doc = "< Next album or NULL if last album"]
    pub next: *mut LIBMTP_album_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_album_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_album_struct>(),
        72usize,
        concat!("Size of: ", stringify!(LIBMTP_album_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_album_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_album_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).album_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(album_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).parent_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).storage_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(storage_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).artist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(artist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).composer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(composer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).genre as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(genre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).tracks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(tracks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).no_tracks as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(no_tracks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_album_struct>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_album_struct),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " MTP Folder structure"]
#[repr(C)]
pub struct LIBMTP_folder_struct {
    #[doc = "< Unique folder ID"]
    pub folder_id: u32,
    #[doc = "< ID of parent folder"]
    pub parent_id: u32,
    #[doc = "< ID of storage holding this folder"]
    pub storage_id: u32,
    #[doc = "< Name of folder"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Next folder at same level or NULL if no more"]
    pub sibling: *mut LIBMTP_folder_t,
    #[doc = "< Child folder or NULL if no children"]
    pub child: *mut LIBMTP_folder_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_folder_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_folder_struct>(),
        40usize,
        concat!("Size of: ", stringify!(LIBMTP_folder_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_folder_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_folder_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).folder_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(folder_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).parent_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).storage_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(storage_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).sibling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_folder_struct>())).child as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_folder_struct),
            "::",
            stringify!(child)
        )
    );
}
#[doc = " LIBMTP Object RepresentativeSampleData Structure"]
#[repr(C)]
pub struct LIBMTP_filesampledata_struct {
    #[doc = "< Width of sample if it is an image"]
    pub width: u32,
    #[doc = "< Height of sample if it is an image"]
    pub height: u32,
    #[doc = "< Duration in milliseconds if it is audio"]
    pub duration: u32,
    #[doc = "< Filetype used for the sample"]
    pub filetype: LIBMTP_filetype_t,
    #[doc = "< Size of sample data in bytes"]
    pub size: u64,
    #[doc = "< Sample data"]
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_LIBMTP_filesampledata_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_filesampledata_struct>(),
        32usize,
        concat!("Size of: ", stringify!(LIBMTP_filesampledata_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_filesampledata_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_filesampledata_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).filetype as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_filesampledata_struct>())).data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_filesampledata_struct),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " LIBMTP Device Storage structure"]
#[repr(C)]
pub struct LIBMTP_devicestorage_struct {
    #[doc = "< Unique ID for this storage"]
    pub id: u32,
    #[doc = "< Storage type"]
    pub StorageType: u16,
    #[doc = "< Filesystem type"]
    pub FilesystemType: u16,
    #[doc = "< Access capability"]
    pub AccessCapability: u16,
    #[doc = "< Maximum capability"]
    pub MaxCapacity: u64,
    #[doc = "< Free space in bytes"]
    pub FreeSpaceInBytes: u64,
    #[doc = "< Free space in objects"]
    pub FreeSpaceInObjects: u64,
    #[doc = "< A brief description of this storage"]
    pub StorageDescription: *mut ::std::os::raw::c_char,
    #[doc = "< A volume identifier"]
    pub VolumeIdentifier: *mut ::std::os::raw::c_char,
    #[doc = "< Next storage, follow this link until NULL"]
    pub next: *mut LIBMTP_devicestorage_t,
    #[doc = "< Previous storage"]
    pub prev: *mut LIBMTP_devicestorage_t,
}
#[test]
fn bindgen_test_layout_LIBMTP_devicestorage_struct() {
    assert_eq!(
        ::std::mem::size_of::<LIBMTP_devicestorage_struct>(),
        72usize,
        concat!("Size of: ", stringify!(LIBMTP_devicestorage_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<LIBMTP_devicestorage_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(LIBMTP_devicestorage_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).StorageType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(StorageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).FilesystemType as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(FilesystemType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).AccessCapability as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(AccessCapability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).MaxCapacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(MaxCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).FreeSpaceInBytes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(FreeSpaceInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).FreeSpaceInObjects as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(FreeSpaceInObjects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).StorageDescription as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(StorageDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).VolumeIdentifier as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(VolumeIdentifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).next as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LIBMTP_devicestorage_struct>())).prev as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LIBMTP_devicestorage_struct),
            "::",
            stringify!(prev)
        )
    );
}
pub const LIBMTP_event_enum_LIBMTP_EVENT_NONE: LIBMTP_event_enum = 0;
pub const LIBMTP_event_enum_LIBMTP_EVENT_STORE_ADDED: LIBMTP_event_enum = 1;
pub const LIBMTP_event_enum_LIBMTP_EVENT_STORE_REMOVED: LIBMTP_event_enum = 2;
pub const LIBMTP_event_enum_LIBMTP_EVENT_OBJECT_ADDED: LIBMTP_event_enum = 3;
pub const LIBMTP_event_enum_LIBMTP_EVENT_OBJECT_REMOVED: LIBMTP_event_enum = 4;
pub const LIBMTP_event_enum_LIBMTP_EVENT_DEVICE_PROPERTY_CHANGED: LIBMTP_event_enum = 5;
#[doc = " LIBMTP Event structure"]
#[doc = " TODO: add all externally visible events here"]
pub type LIBMTP_event_enum = ::std::os::raw::c_uint;
pub use self::LIBMTP_event_enum as LIBMTP_event_t;
extern "C" {
    pub static mut LIBMTP_debug: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @defgroup internals The libmtp internals API."]
    #[doc = " @{"]
    pub fn LIBMTP_Set_Debug(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LIBMTP_Init();
}
extern "C" {
    pub fn LIBMTP_Get_Supported_Devices_List(
        arg1: *mut *mut LIBMTP_device_entry_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup basic The basic device management API."]
    #[doc = " @{"]
    pub fn LIBMTP_Detect_Raw_Devices(
        arg1: *mut *mut LIBMTP_raw_device_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> LIBMTP_error_number_t;
}
extern "C" {
    pub fn LIBMTP_Check_Specific_Device(
        busno: ::std::os::raw::c_int,
        devno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Open_Raw_Device(arg1: *mut LIBMTP_raw_device_t) -> *mut LIBMTP_mtpdevice_t;
}
extern "C" {
    pub fn LIBMTP_Open_Raw_Device_Uncached(
        arg1: *mut LIBMTP_raw_device_t,
    ) -> *mut LIBMTP_mtpdevice_t;
}
extern "C" {
    pub fn LIBMTP_Get_First_Device() -> *mut LIBMTP_mtpdevice_t;
}
extern "C" {
    pub fn LIBMTP_Get_Connected_Devices(
        arg1: *mut *mut LIBMTP_mtpdevice_t,
    ) -> LIBMTP_error_number_t;
}
extern "C" {
    pub fn LIBMTP_Number_Devices_In_List(arg1: *mut LIBMTP_mtpdevice_t) -> u32;
}
extern "C" {
    pub fn LIBMTP_Release_Device_List(arg1: *mut LIBMTP_mtpdevice_t);
}
extern "C" {
    pub fn LIBMTP_Release_Device(arg1: *mut LIBMTP_mtpdevice_t);
}
extern "C" {
    pub fn LIBMTP_Dump_Device_Info(arg1: *mut LIBMTP_mtpdevice_t);
}
extern "C" {
    pub fn LIBMTP_Reset_Device(arg1: *mut LIBMTP_mtpdevice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Manufacturername(
        arg1: *mut LIBMTP_mtpdevice_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_Modelname(arg1: *mut LIBMTP_mtpdevice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_Serialnumber(arg1: *mut LIBMTP_mtpdevice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_Deviceversion(arg1: *mut LIBMTP_mtpdevice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_Friendlyname(arg1: *mut LIBMTP_mtpdevice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Set_Friendlyname(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Syncpartner(arg1: *mut LIBMTP_mtpdevice_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Set_Syncpartner(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Batterylevel(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut u8,
        arg3: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Secure_Time(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Device_Certificate(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Supported_Filetypes(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut *mut u16,
        arg3: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Check_Capability(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_devicecap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Errorstack(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_error_t;
}
extern "C" {
    pub fn LIBMTP_Clear_Errorstack(arg1: *mut LIBMTP_mtpdevice_t);
}
extern "C" {
    pub fn LIBMTP_Dump_Errorstack(arg1: *mut LIBMTP_mtpdevice_t);
}
extern "C" {
    pub fn LIBMTP_Get_Storage(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Format_Storage(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_devicestorage_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get/set arbitrary properties.  These do not update the cache; should only be used on"]
    #[doc = " properties not stored in structs"]
    pub fn LIBMTP_Get_String_From_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_u64_From_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u64,
    ) -> u64;
}
extern "C" {
    pub fn LIBMTP_Get_u32_From_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u32,
    ) -> u32;
}
extern "C" {
    pub fn LIBMTP_Get_u16_From_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u16,
    ) -> u16;
}
extern "C" {
    pub fn LIBMTP_Get_u8_From_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u8,
    ) -> u8;
}
extern "C" {
    pub fn LIBMTP_Set_Object_String(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Object_u32(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Object_u16(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Object_u8(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_property_t,
        arg4: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Property_Description(
        inproperty: LIBMTP_property_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Is_Property_Supported(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_property_t,
        arg3: LIBMTP_filetype_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Allowed_Property_Values(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_property_t,
        arg3: LIBMTP_filetype_t,
        arg4: *mut LIBMTP_allowed_values_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_destroy_allowed_values_t(arg1: *mut LIBMTP_allowed_values_t);
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup files The file management API."]
    #[doc = " @{"]
    pub fn LIBMTP_new_file_t() -> *mut LIBMTP_file_t;
}
extern "C" {
    pub fn LIBMTP_destroy_file_t(arg1: *mut LIBMTP_file_t);
}
extern "C" {
    pub fn LIBMTP_Get_Filetype_Description(
        arg1: LIBMTP_filetype_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn LIBMTP_Get_Filelisting(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_file_t;
}
extern "C" {
    pub fn LIBMTP_Get_Filelisting_With_Callback(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_progressfunc_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> *mut LIBMTP_file_t;
}
extern "C" {
    pub fn LIBMTP_Get_Files_And_Folders(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u32,
    ) -> *mut LIBMTP_file_t;
}
extern "C" {
    pub fn LIBMTP_Get_Filemetadata(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> *mut LIBMTP_file_t;
}
extern "C" {
    pub fn LIBMTP_Get_File_To_File(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: *const ::std::os::raw::c_char,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_File_To_File_Descriptor(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: ::std::os::raw::c_int,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_File_To_Handler(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: MTPDataPutFunc,
        arg4: *mut ::std::os::raw::c_void,
        arg5: LIBMTP_progressfunc_t,
        arg6: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_File_From_File(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut LIBMTP_file_t,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_File_From_File_Descriptor(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut LIBMTP_file_t,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_File_From_Handler(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: MTPDataGetFunc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut LIBMTP_file_t,
        arg5: LIBMTP_progressfunc_t,
        arg6: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_File_Name(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_file_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_new_filesampledata_t() -> *mut LIBMTP_filesampledata_t;
}
extern "C" {
    pub fn LIBMTP_destroy_filesampledata_t(arg1: *mut LIBMTP_filesampledata_t);
}
extern "C" {
    pub fn LIBMTP_Get_Representative_Sample_Format(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_filetype_t,
        arg3: *mut *mut LIBMTP_filesampledata_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_Representative_Sample(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: *mut LIBMTP_filesampledata_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Representative_Sample(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: *mut LIBMTP_filesampledata_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Thumbnail(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup tracks The track management API."]
    #[doc = " @{"]
    pub fn LIBMTP_new_track_t() -> *mut LIBMTP_track_t;
}
extern "C" {
    pub fn LIBMTP_destroy_track_t(arg1: *mut LIBMTP_track_t);
}
extern "C" {
    pub fn LIBMTP_Get_Tracklisting(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_track_t;
}
extern "C" {
    pub fn LIBMTP_Get_Tracklisting_With_Callback(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_progressfunc_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> *mut LIBMTP_track_t;
}
extern "C" {
    pub fn LIBMTP_Get_Tracklisting_With_Callback_For_Storage(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: LIBMTP_progressfunc_t,
        arg4: *const ::std::os::raw::c_void,
    ) -> *mut LIBMTP_track_t;
}
extern "C" {
    pub fn LIBMTP_Get_Trackmetadata(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
    ) -> *mut LIBMTP_track_t;
}
extern "C" {
    pub fn LIBMTP_Get_Track_To_File(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: *const ::std::os::raw::c_char,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Track_To_File_Descriptor(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: ::std::os::raw::c_int,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Get_Track_To_Handler(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: MTPDataPutFunc,
        arg4: *mut ::std::os::raw::c_void,
        arg5: LIBMTP_progressfunc_t,
        arg6: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_Track_From_File(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut LIBMTP_track_t,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_Track_From_File_Descriptor(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut LIBMTP_track_t,
        arg4: LIBMTP_progressfunc_t,
        arg5: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Send_Track_From_Handler(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: MTPDataGetFunc,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut LIBMTP_track_t,
        arg5: LIBMTP_progressfunc_t,
        arg6: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Update_Track_Metadata(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const LIBMTP_track_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Track_Exists(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Track_Name(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_track_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup folders The folder management API."]
    #[doc = " @{"]
    pub fn LIBMTP_new_folder_t() -> *mut LIBMTP_folder_t;
}
extern "C" {
    pub fn LIBMTP_destroy_folder_t(arg1: *mut LIBMTP_folder_t);
}
extern "C" {
    pub fn LIBMTP_Get_Folder_List(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_folder_t;
}
extern "C" {
    pub fn LIBMTP_Get_Folder_List_For_Storage(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
    ) -> *mut LIBMTP_folder_t;
}
extern "C" {
    pub fn LIBMTP_Find_Folder(arg1: *mut LIBMTP_folder_t, arg2: u32) -> *mut LIBMTP_folder_t;
}
extern "C" {
    pub fn LIBMTP_Create_Folder(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: u32,
        arg4: u32,
    ) -> u32;
}
extern "C" {
    pub fn LIBMTP_Set_Folder_Name(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_folder_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup playlists The audio/video playlist management API."]
    #[doc = " @{"]
    pub fn LIBMTP_new_playlist_t() -> *mut LIBMTP_playlist_t;
}
extern "C" {
    pub fn LIBMTP_destroy_playlist_t(arg1: *mut LIBMTP_playlist_t);
}
extern "C" {
    pub fn LIBMTP_Get_Playlist_List(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_playlist_t;
}
extern "C" {
    pub fn LIBMTP_Get_Playlist(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> *mut LIBMTP_playlist_t;
}
extern "C" {
    pub fn LIBMTP_Create_New_Playlist(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_playlist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Update_Playlist(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_playlist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Playlist_Name(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_playlist_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup albums The audio/video album management API."]
    #[doc = " @{"]
    pub fn LIBMTP_new_album_t() -> *mut LIBMTP_album_t;
}
extern "C" {
    pub fn LIBMTP_destroy_album_t(arg1: *mut LIBMTP_album_t);
}
extern "C" {
    pub fn LIBMTP_Get_Album_List(arg1: *mut LIBMTP_mtpdevice_t) -> *mut LIBMTP_album_t;
}
extern "C" {
    pub fn LIBMTP_Get_Album_List_For_Storage(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
    ) -> *mut LIBMTP_album_t;
}
extern "C" {
    pub fn LIBMTP_Get_Album(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> *mut LIBMTP_album_t;
}
extern "C" {
    pub fn LIBMTP_Create_New_Album(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_album_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Update_Album(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *const LIBMTP_album_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Album_Name(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_album_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup objects The object management API."]
    #[doc = " @{"]
    pub fn LIBMTP_Delete_Object(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Move_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u32,
        arg4: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Copy_Object(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u32,
        arg4: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Set_Object_Filename(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_GetPartialObject(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u64,
        arg4: u32,
        arg5: *mut *mut ::std::os::raw::c_uchar,
        arg6: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_SendPartialObject(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u64,
        arg4: *mut ::std::os::raw::c_uchar,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_BeginEditObject(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_EndEditObject(arg1: *mut LIBMTP_mtpdevice_t, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_TruncateObject(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u32,
        arg3: u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @}"]
#[doc = " @defgroup files The events API."]
#[doc = " @{"]
pub type LIBMTP_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: LIBMTP_event_t,
        arg3: u32,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn LIBMTP_Read_Event(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: *mut LIBMTP_event_t,
        arg3: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Read_Event_Async(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: LIBMTP_event_cb_fn,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LIBMTP_Handle_Events_Timeout_Completed(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @defgroup custom Custom operations API."]
    #[doc = " @{"]
    pub fn LIBMTP_Custom_Operation(
        arg1: *mut LIBMTP_mtpdevice_t,
        arg2: u16,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
